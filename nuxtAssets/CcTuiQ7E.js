var u=Object.defineProperty;var I=(h,e,r)=>e in h?u(h,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):h[e]=r;var w=(h,e,r)=>I(h,typeof e!="symbol"?e+"":e,r);import{K as o,V as i,ab as _,M as n,X as d,am as t,au as s,av as m,aw as l,ak as g,a as c,ax as T}from"./dVWTdz__.js";class b{constructor(e){w(this,"id");w(this,"name");w(this,"db");this.name=e}setDB(e){this.db=e}static from_drizzle(e){let r=new b(e.name);return r.id=e.id,r}async update_db(){var e,r;if(this.id===void 0){let a=await((e=this.db)==null?void 0:e.insert(o).values({name:this.name}).returning());if(a&&a.length>0)this.id=a[0].id;else throw new Error("Failed to insert team into database")}else await((r=this.db)==null?void 0:r.update(o).set({name:this.name}).where(i(o.id,this.id)))}async get_match_count(){return(await this.db.select({cnt:_()}).from(n).where(d(i(n.team1ID,this.id),i(n.team2ID,this.id))))[0].cnt}async get_match_wins(){let e=(await this.db.select({cnt:_()}).from(t).where(s(i(t.battingTeamID,this.id),l(t.target,-1),m(t.runs,t.target))))[0].cnt,r=(await this.db.select({cnt:_()}).from(t).where(s(i(t.bowlingTeamID,this.id),l(t.target,-1),g`${t.runs} < ${t.target}-1`,d(m(t.balls,t.max_balls),s(l(t.target,-1),m(t.runs,t.target)),s(g`json_array_length(${t.id_YetToBat}) = 0`,d(i(t.id_striker,-1),i(t.id_non_striker,-1)))))))[0].cnt;return e+r}async get_match_losses(){let e=(await this.db.select({cnt:_()}).from(t).where(s(i(t.bowlingTeamID,this.id),l(t.target,-1),m(t.runs,t.target))))[0].cnt,r=(await this.db.select({cnt:_()}).from(t).where(s(i(t.battingTeamID,this.id),l(t.target,-1),g`${t.runs} < ${t.target}-1`,d(m(t.balls,t.max_balls),s(l(t.target,-1),m(t.runs,t.target)),s(g`json_array_length(${t.id_YetToBat}) = 0`,d(i(t.id_striker,-1),i(t.id_non_striker,-1)))))))[0].cnt;return e+r}async get_highest_score(){let e=(await this.db.select({id:t.id,bowlingTeamID:t.bowlingTeamID,runs:t.runs,wickets:t.wickets}).from(t).where(i(t.battingTeamID,this.id)).orderBy(c(t.runs)).limit(1))[0];if(!e)return;let r=(await this.db.select({id:n.id}).from(n).where(d(i(n.id_FirstInning,e.id),i(n.id_SecondInning,e.id))))[0];if(!r)throw new Error("Team get: no match exists for inning");let a=(await this.db.select({name:o.name}).from(o).where(i(o.id,e.bowlingTeamID)))[0];return{runs:e.runs,wickets:e.wickets,matchID:r.id,opponent:a==null?void 0:a.name}}async get_lowest_score(){let e=(await this.db.select({id:t.id,bowlingTeamID:t.bowlingTeamID,runs:t.runs,wickets:t.wickets}).from(t).where(s(i(t.battingTeamID,this.id),d(i(t.target,-1),T(t.runs,t.target)),d(m(t.balls,t.max_balls),s(l(t.target,-1),m(t.runs,t.target)),s(g`json_array_length(${t.id_YetToBat}) = 0`,d(i(t.id_striker,-1),i(t.id_non_striker,-1)))))).orderBy(t.runs).limit(1))[0];if(!e)return;let r=(await this.db.select({id:n.id}).from(n).where(d(i(n.id_FirstInning,e.id),i(n.id_SecondInning,e.id))))[0];if(!r)throw new Error("Team get: no match exists for inning");let a=(await this.db.select({name:o.name}).from(o).where(i(o.id,e.bowlingTeamID)))[0];return{runs:e.runs,wickets:e.wickets,matchID:r.id,opponent:a==null?void 0:a.name}}async biggest_win_by_runs(){let e=(await this.db.select({id:t.id,battingTeamID:t.battingTeamID,runs:t.runs,target:t.target}).from(t).where(s(i(t.bowlingTeamID,this.id),l(t.target,-1),g`${t.runs} < ${t.target}-1`,d(m(t.balls,t.max_balls),s(l(t.target,-1),m(t.runs,t.target)),s(g`json_array_length(${t.id_YetToBat}) = 0`,d(i(t.id_striker,-1),i(t.id_non_striker,-1)))))).orderBy(g`${t.runs}-${t.target}`).limit(1))[0];if(!e)return;let r=(await this.db.select({id:n.id}).from(n).where(d(i(n.id_FirstInning,e.id),i(n.id_SecondInning,e.id))))[0];if(!r)throw new Error("Team get: no match exists for inning");let a=(await this.db.select({name:o.name}).from(o).where(i(o.id,e.battingTeamID)))[0];return{diff:e.target-e.runs-1,matchID:r.id,opponent:a==null?void 0:a.name}}async biggest_win_by_wickets(){let e=(await this.db.select({id:t.id,bowlingTeamID:t.bowlingTeamID,id_striker:t.id_striker,id_non_striker:t.id_non_striker,id_YetToBat:t.id_YetToBat}).from(t).where(s(i(t.battingTeamID,this.id),l(t.target,-1),m(t.runs,t.target),d(m(t.balls,t.max_balls),s(l(t.target,-1),m(t.runs,t.target)),s(g`json_array_length(${t.id_YetToBat}) = 0`,d(i(t.id_striker,-1),i(t.id_non_striker,-1)))))).orderBy(g`
        CASE
          WHEN ${t.id_striker} = -1 OR ${t.id_non_striker} = -1 THEN json_array_length(${t.id_YetToBat})-1
          ELSE json_array_length(${t.id_YetToBat})
        END DESC`).limit(1))[0];if(!e)return;let r=(await this.db.select({id:n.id}).from(n).where(d(i(n.id_FirstInning,e.id),i(n.id_SecondInning,e.id))))[0];if(!r)throw new Error("Team get: no match exists for inning");let a=(await this.db.select({name:o.name}).from(o).where(i(o.id,e.bowlingTeamID)))[0];return{wickets:e.id_YetToBat.length+1-(e.id_striker==-1||e.id_non_striker==-1?1:0),matchID:r.id,opponent:a==null?void 0:a.name}}async highest_runs_chased(){let e=(await this.db.select({id:t.id,bowlingTeamID:t.bowlingTeamID,runs:t.runs,wickets:t.wickets}).from(t).where(s(i(t.battingTeamID,this.id),l(t.target,-1),m(t.runs,t.target),d(m(t.balls,t.max_balls),s(l(t.target,-1),m(t.runs,t.target)),s(g`json_array_length(${t.id_YetToBat}) = 0`,d(i(t.id_striker,-1),i(t.id_non_striker,-1)))))).orderBy(c(t.runs)).limit(1))[0];if(!e)return;let r=(await this.db.select({id:n.id}).from(n).where(d(i(n.id_FirstInning,e.id),i(n.id_SecondInning,e.id))))[0];if(!r)throw new Error("Team get: no match exists for inning");let a=(await this.db.select({name:o.name}).from(o).where(i(o.id,e.bowlingTeamID)))[0];return{runs:e.runs,wickets:e.wickets,matchID:r.id,opponent:a==null?void 0:a.name}}async lowest_runs_defended(){let e=(await this.db.select({id:t.id,battingTeamID:t.battingTeamID,target:t.target}).from(t).where(s(i(t.bowlingTeamID,this.id),l(t.target,-1),g`${t.runs} < ${t.target}-1`,d(m(t.balls,t.max_balls),s(l(t.target,-1),m(t.runs,t.target)),s(g`json_array_length(${t.id_YetToBat}) = 0`,d(i(t.id_striker,-1),i(t.id_non_striker,-1)))))).orderBy(t.target).limit(1))[0];if(!e)return;let r=(await this.db.select({id:n.id}).from(n).where(d(i(n.id_FirstInning,e.id),i(n.id_SecondInning,e.id))))[0];if(!r)throw new Error("Team get: no match exists for inning");let a=(await this.db.select({name:o.name}).from(o).where(i(o.id,e.battingTeamID)))[0];return{target:e.target,matchID:r.id,opponent:a==null?void 0:a.name}}}export{b as T};
